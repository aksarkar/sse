#+TITLE: PIP calibration
#+SETUPFILE: setup.org

* Setup                                                            :noexport:

  #+BEGIN_SRC emacs-lisp
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(mem="4G", venv="sse") :dir /scratch/midway2/aksarkar/sse

  #+RESULTS:
  : Submitted batch job 42548098

  #+BEGIN_SRC ipython
    %matplotlib inline
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[96]:
  :END:

  #+BEGIN_SRC ipython :tangle pip.py
    import glob
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import sse
    import tabix
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

* Introduction

  Here we compare posterior inclusion probabilities (PIPs) computed using the
  Sum of Single Effects (SSE) variational approximation against other methods:

  - [[http://www.sciencedirect.com/science/article/pii/S0002929716300957?via%253Dihub][DAP]] (2016). We used version 1.0, setting \(\phi = 0\) (no heterogeneity
    between groups of samples) and \(\omega = 1\) (matching the
    simulation). (~sse.wrapper.dap~)

  The simulation generative model is as follows (~sse.evaluate._pip_calibration~):

  1. Sample a gene on chromosomes 1-22 which has at least 1,000 SNPs within 100
     kilobases (respecting strand) of the gene start.

     #+NAME: get-genotypes
     #+BEGIN_SRC ipython :tangle pip.py
       genotype_files = ["/project/compbio/geuvadis/genotypes/GEUVADIS.chr{}.PH1PH2_465.IMPFRQFILT_BIALLELIC_PH.annotv2.genotypes.vcf.gz".format(i) for i in range(1, 23)]
     #+END_SRC

     #+RESULTS: get-genotypes
     :RESULTS:
     # Out[21]:
     :END:

     #+BEGIN_SRC ipython
       def filter_genes(row, genotype_files, window, min_num_snps=1000):
         window = int(window)
         chrom = int(row['chr'][2:])
         if row['strand'] == '+':
           start = row['start'] - window
           end = row['start']
         else:
           start = row['start']
           end = row['start'] + window
         count = 0
         for record in tabix.open(genotype_files[chrom - 1]).query(str(chrom), start, end):
           count += 1
           if count > min_num_snps:
             return True
         return False
     #+END_SRC

     #+RESULTS:
     :RESULTS:
     :END:

     #+NAME: get-genes
     #+BEGIN_SRC ipython :async t
       genes = (pd.read_table('/home/aksarkar/projects/singlecell-qtl/data/scqtl-genes.txt.gz')
                .set_index('gene')
                .query('source == "H. sapiens"')
                .query('chr != "hsX"')
                .query('chr != "hsY"')
                .query('chr != "hsMT"'))
       genes = genes[genes.apply(filter_genes, genotype_files=genotype_files, window=int(1e5), axis=1)]
     #+END_SRC

     #+RESULTS: get-genes
     :RESULTS:
     :END:

     Write out the filtered set of genes so we don't have to do this
     long-running query more than once:

     #+NAME: write-genes
     #+BEGIN_SRC ipython
       genes.to_csv('/home/aksarkar/projects/sse/data/genes.txt.gz', sep='\t', compression='gzip')
     #+END_SRC

     #+RESULTS: write-genes
     :RESULTS:
     :END:

     #+NAME: read-genes
     #+BEGIN_SRC ipython :tangle pip.py
       genes = pd.read_table('/home/aksarkar/projects/sse/data/genes.txt.gz', index_col=0)
     #+END_SRC

     #+RESULTS: read-genes
     :RESULTS:
     # Out[16]:
     :END:

  2. Extract genotypes of GEUVADIS individuals \(X\) from 100 kilobases
     upstream (respecting strand) of the gene start (~sse.evaluate.read_vcf~).
  3. [@3] Estimate MAF \(f_j\) from \(X\) (~sse.simulation.Simulation.estimate_maf~)
  4. Fix proportion of variance explained \(h^2 = 0.15\) (mean
     /cis/-heritability of gene expression across all genes; [[https://www.nature.com/articles/ng.3506][Gusev et al 2016]],
     [[https://www.nature.com/articles/ng.3506][Wheeler et al 2016]])
  5. Sample causal effects from \(\beta_j \sim N(0, 1)\)
     (~sse.simulation.Simulation.sample_effects~).
  6. Compute genetic variance \(V_g = \sum_j 2 f_j (1 - f_j) \beta_j^2\)
  7. Sample residuals \(\epsilon_i \sim N(0, V_g (1 / h^2 - 1))\)
  8. Compute phenotypes \(y_i = X_i\beta + \epsilon_i\) (~sse.simulation.Simulation.compute_liabilities~)

* One causal variant

  #+BEGIN_SRC ipython :eval never :tangle pip.py
    one_causal = sse.evaluate.pip_calibration(
      genes=genes,
      genotype_files=genotype_files,
      num_genes=100,
      num_trials=1,
      num_effects=10,
      seed=0)
    one_causal.to_csv('/home/aksarkar/projects/sse/data/one-causal-max-error.txt.gz', sep='\t', compression='gzip')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[22]:
  :END:

  #+BEGIN_SRC ipython
    one_causal = pd.read_table('/home/aksarkar/projects/sse/data/one-causal-max-error.txt.gz', index_col=[0, 1])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[71]:
  :END:

  Tabulate the actual number of variants used in the simulation:

  #+BEGIN_SRC ipython
    one_causal.groupby(level=0).apply(lambda x: x.iloc[0]['num_snps']).describe()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[6]:
  #+BEGIN_EXAMPLE
    count     100.000000
    mean     1381.850000
    std       216.044672
    min      1014.000000
    25%      1230.750000
    50%      1376.500000
    75%      1497.000000
    max      2320.000000
    dtype: float64
  #+END_EXAMPLE
  :END:
 
  #+BEGIN_SRC ipython
    del one_causal['num_snps']
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[7]:
  :END:

  #+BEGIN_SRC ipython
    one_causal.columns = pd.MultiIndex.from_tuples([eval(x) for x in one_causal.columns])
  #+END_SRC

  The distribution of maximum absolute error in PIP is centered away from zero,
  suggesting systematic differences between SSE and the other methods.

  #+BEGIN_SRC ipython :ipyfile one-causal-variant-max-error.png
    plt.clf()
    plt.boxplot(one_causal['error'].fillna(0).values, labels=one_causal['error'].columns)
    plt.xlabel('Method')
    plt.ylabel('Maximum absolute difference in PIP')
    plt.gcf()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[84]:
  [[file:one-causal-variant-max-error.png]]
  :END:

  Looking only at the variant with the maximum discrepancy between SSE/DAP, and
  conditioning on whether the variant was simulated to have a non-zero effect
  size (causal) or not (noncausal), SSE appears to assign higher PIP to
  non-causal variants (i.e., less confidently classifies them as not causal),
  while DAP appears to assign higher PIP to causal variants.

  #+BEGIN_SRC ipython :ipyfile one-causal-pip-scatter.png
    plt.clf()
    keep = np.isclose(one_causal['effect'][k], 0)
    plt.scatter(x=one_causal.loc[keep, 'other_pip']['dap'], y=one_causal.loc[keep, 'sse_pip']['dap'], c='blue', label='Noncausal')
    plt.scatter(x=one_causal.loc[~keep, 'other_pip']['dap'], y=one_causal.loc[~keep, 'sse_pip']['dap'], c='red', label='Causal')
    plt.legend()
    plt.plot([[0, 0], [1, 1]], ls='-', c='k')
    plt.xlim(0, 1)
    plt.xticks(np.linspace(0, 1, 9))
    plt.xlabel('DAP PIP')
    plt.ylim(0, 1)
    plt.yticks(np.linspace(0, 1, 9))
    plt.ylabel('SSE PIP')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[158]:
  : Text(0,0.5,'SSE PIP')
  [[file:one-causal-pip-scatter.png]]
  :END:

  One explanation for the fact that DAP assigns higher PIP to causal variants
  is that SSE loses power to detect causal variants which are extremely rare or
  have small effect size. One explanation for the fact that SSE assigns higher
  PIP to non-causal variants is that they are in moderate LD with the causal variant

  #+BEGIN_SRC ipython :ipyfile one-causal-maf-effect.png
    plt.clf()
    fig, ax = plt.subplots(3, 1)
    fig.set_size_inches(8, 12)
    ax[0].scatter(x=one_causal.loc[keep, 'other_pip']['dap'], y=one_causal.loc[keep, 'maf']['dap'], c='blue', label='Noncausal')
    ax[0].scatter(x=one_causal.loc[~keep, 'other_pip']['dap'], y=one_causal.loc[~keep, 'maf']['dap'], c='red', label='Causal')
    ax[0].legend()
    ax[0].set_xlim(0, 1)
    ax[0].set_xticks(np.linspace(0, 1, 9))
    ax[0].set_ylabel('Minor allele frequency')

    ax[1].scatter(x=one_causal.loc[keep, 'other_pip']['dap'], y=one_causal.loc[keep, 'effect']['dap'], c='blue')
    ax[1].scatter(x=one_causal.loc[~keep, 'other_pip']['dap'], y=one_causal.loc[~keep, 'effect']['dap'], c='red')
    ax[1].axhline(y=0, c='k')
    ax[1].set_xlim(0, 1)
    ax[1].set_xticks(np.linspace(0, 1, 9))
    ax[1].set_ylabel('Effect size')

    ax[2].scatter(x=one_causal.loc[keep, 'other_pip']['dap'], y=one_causal.loc[keep, 'ld']['dap'], c='blue')
    ax[2].axhline(y=0, c='k')
    ax[2].set_xlim(0, 1)
    ax[2].set_xticks(np.linspace(0, 1, 9))
    ax[2].set_ylim(-1, 1)
    ax[2].set_ylabel('Max LD $r^2$ with causal variant')
    ax[2].set_xlabel('DAP PIP')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[160]:
  : Text(0.5,0,'DAP PIP')
  [[file:one-causal-maf-effect.png]]
  :END:

* Two causal variants

  #+BEGIN_SRC ipython :eval never :tangle pip.py
    two_causal = sse.evaluate.pip_calibration(
      genes=genes,
      genotype_files=genotype_files,
      num_genes=100,
      num_trials=1,
      num_causal=2,
      num_effects=10,
      seed=0)
    two_causal.to_csv('/home/aksarkar/projects/sse/data/two-causal-max-error.txt.gz', sep='\t', compression='gzip')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    two_causal = pd.read_table('/home/aksarkar/projects/sse/data/two-causal-max-error.txt.gz', index_col=[0, 1])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[11]:
  :END:

  #+BEGIN_SRC ipython
    del two_causal['num_snps']
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[13]:
  :END:

  #+BEGIN_SRC ipython :ipyfile two-causal-variants-max-error.png
    plt.clf()
    plt.boxplot(two_causal.fillna(0).values, labels=two_causal.columns)
    plt.xlabel('Method')
    plt.ylabel('Maximum absolute difference in PIP')
    plt.gcf()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[14]:
  [[file:two-causal-variants-max-error.png]]
  :END:

* Three causal variants

  #+BEGIN_SRC ipython :eval never :tangle pip.py
    three_causal = sse.evaluate.pip_calibration(
      genes=genes,
      genotype_files=genotype_files,
      num_genes=100,
      num_trials=1,
      num_causal=2,
      num_effects=10,
      seed=0)
    three_causal.to_csv('/home/aksarkar/projects/sse/data/three-causal-max-error.txt.gz', sep='\t', compression='gzip')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    three_causal = pd.read_table('/home/aksarkar/projects/sse/data/three-causal-max-error.txt.gz', index_col=[0, 1])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[11]:
  :END:

  #+BEGIN_SRC ipython
    del three_causal['num_snps']
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[13]:
  :END:

  #+BEGIN_SRC ipython :ipyfile three-causal-variants-max-error.png
    plt.clf()
    plt.boxplot(three_causal.fillna(0).values, labels=three_causal.columns)
    plt.xlabel('Method')
    plt.ylabel('Maximum absolute difference in PIP')
    plt.gcf()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[14]:
  [[file:three-causal-variants-max-error.png]]
  :END:

* Run the code on RCC                                              :noexport:

  #+BEGIN_SRC emacs-lisp
    (org-babel-tangle)
  #+END_SRC

  #+RESULTS:
  | pip.py |

  #+BEGIN_SRC sh
    sbatch --partition="broadwl" --mem=4G --time=400 --job-name="sse"
    #!/bin/bash
    source activate sse
    python pip.py
  #+END_SRC

  #+RESULTS:
  : Submitted batch job 42549822

  #+BEGIN_SRC sh
    sacct -j 42219721 -o Elapsed,MaxRSS,MaxVMSize
  #+END_SRC

  #+RESULTS:
  |    Elapsed | MaxRSS     | MaxVMSize  |
  | ---------- | ---------- | ---------- |
  |   02:14:44 |            |            |
  |   02:14:44 | 263184K    | 1852440K   |


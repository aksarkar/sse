#+TITLE: PIP calibration
#+SETUPFILE: setup.org

* Setup                                                            :noexport:

  #+BEGIN_SRC emacs-lisp
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(mem="4G", venv="sse") :dir /scratch/midway2/aksarkar/sse

  #+RESULTS:
  : Submitted batch job 42223712

  #+BEGIN_SRC ipython :tangle pip.py
    import glob
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import sse
    import tabix
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[1]:
  :END:

* Introduction

  Here we compare posterior inclusion probabilities (PIPs) computed using the
  Sum of Single Effects (SSE) variational approximation against other methods:

  - [[http://www.sciencedirect.com/science/article/pii/S0002929716300957?via%253Dihub][DAP]] (2016). We used version 1.0, setting \(\phi = 0\) (no heterogeneity
    between groups of samples) and \(\omega = 1\) (matching the
    simulation). (~sse.wrapper.dap~)

  The simulation generative model is as follows (~sse.evaluate._pip_calibration~):

  1. Sample a gene on chromosomes 1-22 which has at least 1,000 SNPs within 100
     kilobases (respecting strand) of the gene start.

     #+NAME: get-genotypes
     #+BEGIN_SRC ipython :tangle pip.py
       genotype_files = ["/project/compbio/geuvadis/genotypes/GEUVADIS.chr{}.PH1PH2_465.IMPFRQFILT_BIALLELIC_PH.annotv2.genotypes.vcf.gz".format(i) for i in range(1, 23)]
     #+END_SRC

     #+RESULTS: get-genotypes
     :RESULTS:
     # Out[14]:
     :END:

     #+BEGIN_SRC ipython
       def filter_genes(row, genotype_files, window, min_num_snps=1000):
         window = int(window)
         chrom = int(row['chr'][2:])
         if row['strand'] == '+':
           start = row['start'] - window
           end = row['start']
         else:
           start = row['start']
           end = row['start'] + window
         count = 0
         for record in tabix.open(genotype_files[chrom - 1]).query(str(chrom), start, end):
           count += 1
           if count > min_num_snps:
             return True
         return False
     #+END_SRC

     #+RESULTS:
     :RESULTS:
     :END:

     #+NAME: get-genes
     #+BEGIN_SRC ipython :async t
       genes = (pd.read_table('/home/aksarkar/projects/singlecell-qtl/data/scqtl-genes.txt.gz')
                .set_index('gene')
                .query('source == "H. sapiens"')
                .query('chr != "hsX"')
                .query('chr != "hsY"')
                .query('chr != "hsMT"'))
       genes = genes[genes.apply(filter_genes, genotype_files=genotype_files, window=int(1e5), axis=1)]
     #+END_SRC

     #+RESULTS: get-genes
     :RESULTS:
     :END:

     Write out the filtered set of genes so we don't have to do this
     long-running query more than once:

     #+NAME: write-genes
     #+BEGIN_SRC ipython
       genes.to_csv('/home/aksarkar/projects/sse/data/genes.txt.gz', sep='\t', compression='gzip')
     #+END_SRC

     #+RESULTS: write-genes
     :RESULTS:
     :END:

     #+NAME: read-genes
     #+BEGIN_SRC ipython :tangle pip.py
       genes = pd.read_table('/home/aksarkar/projects/sse/data/genes.txt.gz', index_col=0)
     #+END_SRC

     #+RESULTS: read-genes
     :RESULTS:
     # Out[13]:
     :END:

  2. Extract genotypes of GEUVADIS individuals \(X\) from 100 kilobases
     upstream (respecting strand) of the gene start (~sse.evaluate.read_vcf~).
  3. [@3] Estimate MAF \(f_j\) from \(X\) (~sse.simulation.Simulation.estimate_maf~)
  4. Fix proportion of variance explained \(h^2 = 0.15\) (mean
     /cis/-heritability of gene expression across all genes; [[https://www.nature.com/articles/ng.3506][Gusev et al 2016]],
     [[https://www.nature.com/articles/ng.3506][Wheeler et al 2016]])
  5. Sample causal effects from \(\beta_j \sim N(0, 1)\)
     (~sse.simulation.Simulation.sample_effects~).
  6. Compute genetic variance \(V_g = \sum_j 2 f_j (1 - f_j) \beta_j^2\)
  7. Sample residuals \(\epsilon_i \sim N(0, V_g (1 / h^2 - 1))\)
  8. Compute phenotypes \(y_i = X_i\beta + \epsilon_i\) (~sse.simulation.Simulation.compute_liabilities~)

* One causal variant

  #+BEGIN_SRC ipython :async t
    one_causal = sse.evaluate.pip_calibration(
      genes=genes,
      genotype_files=genotype_files,
      num_genes=100,
      num_trials=1,
      num_effects=10,
      seed=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[5]:
  :END:

  Tabulate the actual number of variants used in the simulation:

  #+BEGIN_SRC ipython
    one_causal.groupby(level=0).apply(lambda x: x.iloc[0]['num_snps']).describe()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[6]:
  #+BEGIN_EXAMPLE
    count     100.000000
    mean     1381.850000
    std       216.044672
    min      1014.000000
    25%      1230.750000
    50%      1376.500000
    75%      1497.000000
    max      2320.000000
    dtype: float64
  #+END_EXAMPLE
  :END:
 
  #+BEGIN_SRC ipython
    del one_causal['num_snps']
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[7]:
  :END:

  #+BEGIN_SRC ipython :ipyfile one-causal-variant-max-error.png
    plt.clf()
    plt.boxplot(one_causal.fillna(0).values, labels=one_causal.columns)
    plt.xlabel('Method')
    plt.ylabel('Maximum absolute difference in PIP')
    plt.gcf()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[8]:
  [[file:one-causal-variant-max-error.png]]
  :END:

* Two causal variants

  #+BEGIN_SRC ipython
    two_causal = sse.evaluate.pip_calibration(
      genes=genes,
      genotype_files=genotype_files,
      num_genes=100,
      num_trials=1,
      num_causal=2,
      num_effects=10,
      seed=0)
    two_causal.to_csv('/home/aksarkar/projects/sse/data/two-causal-max-error.txt.gz', sep='\t', compression='gzip')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC emacs-lisp
    (org-tangle-buffer)
  #+END_SRC

  #+BEGIN_SRC sh
    sbatch --partition="broadwl" --mem=4G --time=200 --job-name="sse"
    #!/bin/bash
    source activate sse
    python pip.py
  #+END_SRC

  #+RESULTS:
  : Submitted batch job 42219721

  #+BEGIN_SRC sh
    sacct -j 42219721 -o Elapsed,MaxRSS,MaxVMSize
  #+END_SRC

  #+RESULTS:
  |    Elapsed | MaxRSS     | MaxVMSize  |
  | ---------- | ---------- | ---------- |
  |   02:14:44 |            |            |
  |   02:14:44 | 263184K    | 1852440K   |

  #+BEGIN_SRC ipython
    two_causal = pd.read_table('/home/aksarkar/projects/sse/data/two-causal-max-error.txt.gz', index_col=[0, 1])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[11]:
  :END:

  #+BEGIN_SRC ipython
    del two_causal['num_snps']
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[13]:
  :END:

  #+BEGIN_SRC ipython :ipyfile two-causal-variants-max-error.png
    plt.clf()
    plt.boxplot(two_causal.fillna(0).values, labels=two_causal.columns)
    plt.xlabel('Method')
    plt.ylabel('Maximum absolute difference in PIP')
    plt.gcf()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[14]:
  [[file:two-causal-variants-max-error.png]]
  :END:
